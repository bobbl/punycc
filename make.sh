#!/bin/sh


help () {
    echo "Usage: $0 <action> ..."
    echo
    echo "  x86              Set ISA to Intel x86 32 bit (default)"
    echo "  rv32             Set ISA to RISC-V RV32IM"
    echo "  armv6m           Set ISA to ARMv6-M (minimal thumb ISA of Cortex-M0)"
    echo "  wasm             Set ISA to WebAssembly"
    echo "  or1k             Set ISA to OpenRISC 1000"
    echo
    echo "  compile_native   Compile for ISA with the native compiler of the platform"
    echo "  compile_all      Compile native for all ISAs, then all cross combinations"
    echo "  stats            Binary sizes of all self-compiled cross compilers"
    echo
    echo "  test_self        Build compiler for ISA"
    echo "  test_tox86       Use ISA compiler to build cross compiler from ISA to x86"
    echo "  test_cc500       Compile cc500 with cross compiler and check against original"
    echo "  test_multi       Build 3 compilers for every ISA: self, tox86 and cc500"
    echo "  test_full        Build every cross compiler on every platform and compare"
    echo "  test_full_par    Same with multiple processes"
    echo
    echo "  disasm <elf>     Disassemble raw ELF with current ISA"
    echo "  asm_riscv <code> Assemble to rv32 machine code"
    echo "                   Surround by \" and separate commands by ;"
    echo
    echo "Environment variables:"
    echo "  CC=         native compiler (gcc or clang)"
    echo "  QEMU_RV32=  path to qemu-riscv32 (if not in the search path)"
    echo "  QEMU_ARM=   path to qemu-arm"
}

if [ $# -eq 0 ] 
then
    help
    exit 1
fi




CC=${CC:-clang}
QEMU_RV32=${QEMU_RV32:-qemu-riscv32}
QEMU_ARM=${QEMU_ARM:-qemu-arm}
QEMU_OR1K=${QEMU_OR1K:-qemu-or1k}

arch_list="wasm	x86	armv6m	rv32	or1k"



qemu () {
    case $arch in
        x86)    ;;
        rv32)   echo "$QEMU_RV32" ;;
        armv6m) echo "$QEMU_ARM" ;;
        wasm)   echo "wasmtime" ;;
        or1k)   echo "$QEMU_OR1K" ;;
    esac
}




# build punycc with the native compiler of the platform (gcc or clang)
# $1 architecture
compile_native () {
    cat ../host_native.c ../emit_$1.c ../punycc.c > punycc_$1.c
    "$CC" -O2 -o punycc_$1.native punycc_$1.c
}


# use native compler for host to compile a punycc cross compiler 
# $1 host architecture
# $2 target architecture
compile_cross () {
    cat ../host_$1.c ../emit_$2.c ../punycc.c > punycc_$2.$1.c
    ./punycc_$1.native < punycc_$2.$1.c > punycc_$2.$1
    errorlevel=$?
    if [ $errorlevel -ne 0 ]
    then
        echo "Error $errorlevel"
        exit $errorlevel
    fi
    chmod +x punycc_$2.$1
}


compile_triple () {
    arch=$1
    target=$2
    host=$3

    $(qemu) ./punycc_$host.$arch < punycc_$target.$host.c > tmp.$arch.$host.$target
    errorlevel=$?
    if [ $errorlevel -ne 0 ]
    then
        echo "$arch $target $host Error $errorlevel"
        exit $errorlevel
    fi
}


compile_all () {
    for host in $arch_list
    do
        compile_native $host
        for target in $arch_list
        do
            compile_cross $host $target
        done
    done
}


stats () {
    compile_all
    echo "        hosts"
    echo "target  $arch_list"
    for target in $arch_list
    do
        printf "$target\t"
        for host in $arch_list
        do
            filesize=$(stat -c '%s' punycc_$target.$host)
            printf "$filesize\t"
        done
        echo
    done
}


# use the clang cross compiler to build a compiler for the current arch
test_self () {
    compile_native $arch
    compile_cross $arch $arch
    echo $arch compiler size: $(wc -c < punycc_$arch.$arch)
}



# use the compiler for the current arch to compile a cross compiler
# from this arch to x86
test_tox86 () {
    cat ../host_$arch.c ../emit_x86.c ../punycc.c > punycc_tox86.$arch.c
    $(qemu) ./punycc_$arch.$arch < punycc_tox86.$arch.c > punycc_tox86.$arch
    errorlevel=$?
    if [ $errorlevel -ne 0 ]
    then
        echo "Error $errorlevel"
        exit $errorlevel
    fi
    chmod +x punycc_tox86.$arch
    echo cross compiler $arch to x86 size: $(wc -c < punycc_tox86.$arch)
}



test_cc500 () {
    # use the compiled binary to compile the modified original
    cat ../host_x86.c ../cc500/cc500_mod.c > tmp.c
    $(qemu) ./punycc_tox86.$arch < tmp.c > cc500_mod.x86

    # use the compiled (modified) original to compile the original
    chmod +x cc500_mod.x86
    ./cc500_mod.x86 < ../cc500/cc500.c > cc500.cc500
    cmp cc500.cc500 ../cc500/cc500.correct.x86
    echo original size: $(wc -c < cc500_mod.x86) instead of 16458
}


test_multi () {
    for arch in $arch_list
    do
        compile_native $arch
        echo "-------------------------------------------------------------"
        test_self
        test_tox86
        test_cc500
        echo "============================================================="
    done
}


# For every arch, generate all cross compilers and compare them to the
# reference generated by the native c compiler
test_full () {
    compile_all
    for arch in $arch_list
    do
        for target in $arch_list
        do
            for host in $arch_list
            do
                printf "%s %s %s        \r" $arch $target $host
                compile_triple $arch $target $host
                diff punycc_$target.$host tmp.$arch.$host.$target
            done
        done
    done
}


# Same as test_full, but with multiple parallel processes
test_full_par () {
    echo "Building reference ..."
    compile_all
    echo "Building in parallel ..."
    for arch in $arch_list
    do
        for target in $arch_list
        do
            for host in $arch_list
            do
                compile_triple $arch $target $host &
            done
        done
    done
    wait
    for arch in $arch_list
    do
        for target in $arch_list
        do
            for host in $arch_list
            do
                printf "%s %s %s        \r" $arch $target $host
                diff punycc_$target.$host tmp.$arch.$host.$target
            done
        done
    done
}



arch="x86"

mkdir -p build
cd build

while [ $# -ne 0 ]
do
    case $1 in
        help)           help ;;

        x86)            arch="x86" ;;
        rv32)           arch="rv32" ;;
        armv6m)         arch="armv6m" ;;
        wasm)           arch="wasm" ;;
        or1k)           arch="or1k" ;;

        compile_native) compile_native $arch ;;
        compile_all)    compile_all ;;
        stats)          stats ;;

        test_self)      test_self ;;
        test_tox86)     test_tox86 ;;
        test_cc500)     test_cc500 ;;
        test_multi)     test_multi ;;
        test_full)      test_full ;;
        test_full_par)  test_full_par ;;


        disasm)
            cd ..
            case $arch in
                x86)    objdump -b binary -m i386 -M intel -D "$2"
                        ;;
                rv32)   riscv64-linux-gnu-objdump -b binary -m riscv -D "$2"
                        ;;
                armv6m) arm-none-eabi-objdump -b binary -m arm -M force-thumb -D "$2"
                        ;;
                or1k)   or1k-elf-objdump -b binary -m or1k -EB -D "$2"
                        ;;
            esac
            shift
            cd build
            ;;

        asm_riscv)
            echo "$2" | riscv64-linux-gnu-as - -o tmp.elf
            riscv64-linux-gnu-objdump -Mnumeric -d tmp.elf | tail -n +8 > tmp.dump
            cat tmp.dump
            sed -n -e 's/....:.\(..\)\(..\)\(..\)\(..\).*/\\x\4\\x\3\\x\2\\x\1/p' \
                tmp.dump | tr -d '\n'
            echo
            printf "%d\n" 0x$(cut -f 2 tmp.dump)
            rm tmp.elf tmp.dump
            shift
            ;;

        asm_riscv_file)
            cat "$2" | riscv64-linux-gnu-as - -o tmp.elf
            riscv64-linux-gnu-objdump -Mnumeric -d tmp.elf | tail -n +8 > tmp.dump
            cat tmp.dump
            sed -n -e 's/....:.\(..\)\(..\)\(..\)\(..\).*/\\x\4\\x\3\\x\2\\x\1/p' \
                tmp.dump | tr -d '\n'
            echo
            rm tmp.elf tmp.dump
            shift
            ;;

        asm_or1k)
            echo "$2" | or1k-elf-as - -o tmp.elf
            or1k-elf-objdump -d tmp.elf | tail -n +8 > tmp.dump
            cat tmp.dump
            sed -n -e 's/....:.\(..\) \(..\) \(..\) \(..\).*/\\x\1\\x\2\\x\3\\x\4/p' \
                tmp.dump | tr -d '\n'
            echo
            printf "%d\n" 0x$(cut -c 7-8,10-11,13-14,16-17 tmp.dump)
            rm tmp.elf tmp.dump
            shift
            ;;

        clean)
            rm -f *
            ;;

        *)
            echo "Unknown target $1. Stop."
            exit 1
            ;;
    esac
    shift
done

cd ..


# SPDX-License-Identifier: ISC

